#!/usr/bin/env node

/**
 * Process Jest test results and generate a formatted report of failed tests
 *
 * Usage: npm run test:report
 * This script reads test-results.json and creates test-failures-report.md
 */

const fs = require('fs');
const path = require('path');

function processTestResults() {
  const resultsPath = path.join(__dirname, '..', 'test-results.json');
  const reportPath = path.join(__dirname, '..', 'test-failures-report.md');

  // Check if test results file exists
  if (!fs.existsSync(resultsPath)) {
    console.error('❌ test-results.json not found. Run tests with --outputFile=test-results.json first.');
    process.exit(1);
  }

  try {
    // Read and parse test results
    const rawData = fs.readFileSync(resultsPath, 'utf8');
    const data = JSON.parse(rawData);

    // Generate report
    const report = generateFailureReport(data);

    // Write report to file
    fs.writeFileSync(reportPath, report, 'utf8');

    // Also log to console
    console.log('\n📋 Test Failure Report Generated');
    console.log('=' .repeat(50));
    console.log(report);
    console.log('=' .repeat(50));
    console.log(`📄 Full report saved to: ${reportPath}`);

  } catch (error) {
    console.error('❌ Error processing test results:', error.message);
    process.exit(1);
  }
}

function generateFailureReport(data) {
  const { numFailedTests, numFailedTestSuites, testResults, startTime, endTime } = data;
  const duration = endTime - startTime;

  let report = `# Test Failures Report\n\n`;
  report += `**Generated:** ${new Date().toISOString()}\n`;
  report += `**Duration:** ${Math.round(duration / 1000)}s\n`;
  report += `**Total Test Suites:** ${data.numTotalTestSuites}\n`;
  report += `**Passed:** ${data.numPassedTestSuites}\n`;
  report += `**Failed:** ${numFailedTestSuites}\n`;
  report += `**Total Tests:** ${data.numTotalTests}\n`;
  report += `**Passed:** ${data.numPassedTests}\n`;
  report += `**Failed:** ${numFailedTests}\n\n`;

  if (numFailedTests === 0) {
    report += `## ✅ All tests passed!\n\n`;
    report += `No failing tests to report.\n`;
    return report;
  }

  report += `## ❌ Failed Tests (${numFailedTests})\n\n`;

  // Process each test suite
  for (const suite of testResults) {
    const failedTests = suite.assertionResults.filter(test => test.status === 'failed');

    if (failedTests.length > 0) {
      report += `### ${suite.name}\n\n`;
      report += `**Status:** ${suite.status}\n`;
      report += `**Tests:** ${suite.numPassingAsserts || 0} passed, ${suite.numFailingTests || failedTests.length} failed\n\n`;

      for (const test of failedTests) {
        report += `#### 🧪 ${test.fullName}\n\n`;
        report += `- **File:** \`${suite.name}\`\n`;
        report += `- **Status:** ❌ Failed\n`;
        report += `- **Duration:** ${test.duration}ms\n`;

        if (test.failureMessages && test.failureMessages.length > 0) {
          report += `- **Error:**\n`;
          for (const message of test.failureMessages) {
            // Clean up the error message for better readability
            const cleanMessage = message
              .replace(/\s+/g, ' ')
              .replace(/\\n/g, '\n')
              .trim();
            report += `  \`\`\`\n  ${cleanMessage}\n  \`\`\`\n\n`;
          }
        }

        report += `---\n\n`;
      }
    }
  }

  // Add summary section
  report += `## 📊 Summary\n\n`;
  report += `This report contains ${numFailedTests} failed test(s) across ${numFailedTestSuites} test suite(s).\n`;
  report += `Review each failure above and address the underlying issues.\n\n`;

  // Add next steps
  report += `## 🔧 Next Steps\n\n`;
  report += `1. **Review each failed test** and understand the root cause\n`;
  report += `2. **Fix the failing code** or update test expectations\n`;
  report += `3. **Run tests again** to verify fixes\n`;
  report += `4. **Update this report** by running: \`npm run test:report\`\n\n`;

  report += `---\n\n`;
  report += `*Report generated by process-test-results.js*`;

  return report;
}

// Run the processor if this script is called directly
if (require.main === module) {
  processTestResults();
}

module.exports = { processTestResults, generateFailureReport };